# subtitle_generator.py
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import os
import datetime
from pathlib import Path
from config import config

def generate_ass_subtitle(segments, output_path, video_info=None):
    """모듈 함수: ASS 자막 생성"""
    generator = ASSSubtitleGenerator()
    return generator.generate_full_subtitle(segments, output_path, video_info)

class ASSSubtitleGenerator:
    """ASS 자막 생성을 위한 클래스"""
    
    def __init__(self):
        # 기본 설정을 config에서 로드
        self.default_font = config.get('font', 'default_font')
        self.default_font_size = config.get('font', 'default_size')
        self.volume_size_multipliers = config.get('font', 'size_multipliers')
        self.voice_fonts = config.get('font', 'voice_fonts')  # 음성 타입별 폰트
        self.volume_sizes = config.get('volume', 'sizes')
        self.pitch_outlines = config.get('outline', 'pitch_levels')
        self.speech_rate_spacing = config.get('spacing', 'speech_rate')
        self.emotion_colors = config.get('colors', 'emotion_colors')
        self.default_color = config.get('colors', 'default_color')

    def _format_time(self, seconds):
        """초단위 시간을 ASS 포맷(H:MM:SS.CS)으로 변환"""
        h  = int(seconds // 3600)
        m  = int((seconds % 3600) // 60)
        s  = int(seconds % 60)
        cs = int((seconds % 1) * 100)
        return f"{h}:{m:02}:{s:02}.{cs:02}"
    
    def generate_ass_header(self, video_info=None):
        """ASS 자막 헤더 생성"""
        width  = video_info.get('width', 1920) if video_info else 1920
        height = video_info.get('height',1080) if video_info else 1080
        now    = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        
        header  = "[Script Info]\n"
        header += "; Script generated by ASS Subtitle Generator\n"
        header += f"; Created: {now}\n"
        header += "ScriptType: v4.00+\n"
        header += f"PlayResX: {width}\n"
        header += f"PlayResY: {height}\n\n"
        
        # Styles 정의
        header += "[V4+ Styles]\n"
        header += ("Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, "
                   "OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, "
                   "ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, "
                   "MarginL, MarginR, MarginV, Encoding\n")
        # 기본 스타일
        header += (f"Style: Default,{self.default_font},{self.default_font_size},&HFFFFFF,"
                   "&HFFFFFF,&H000000,&H80000000,0,0,0,0,100,100,0,0,1,2,1,2,10,10,10,1\n")
        # Whisper/Normal/Shout 스타일 (완전한 정의)
        w_sz = int(self.default_font_size * self.volume_size_multipliers['whisper'])
        n_sz = self.default_font_size
        s_sz = int(self.default_font_size * self.volume_size_multipliers['shout'])
        
        # 음성 타입별 폰트 설정
        whisper_font = self.voice_fonts.get('whisper', self.default_font)
        normal_font = self.voice_fonts.get('normal', self.default_font)
        shout_font = self.voice_fonts.get('shout', self.default_font)
        
        header += (f"Style: Whisper,{whisper_font},{w_sz},&HFFFFFF,"
                   "&HFFFFFF,&H000000,&H80000000,0,1,0,0,100,100,0,0,1,2,1,2,10,10,10,1\n")  # 이탤릭
        header += (f"Style: Normal,{normal_font},{n_sz},&HFFFFFF,"
                   "&HFFFFFF,&H000000,&H80000000,0,0,0,0,100,100,0,0,1,2,1,2,10,10,10,1\n")   # 일반
        header += (f"Style: Shout,{shout_font},{s_sz},&HFFFFFF,"
                   "&HFFFFFF,&H000000,&H80000000,0,0,0,0,100,100,0,0,1,2,1,2,10,10,10,1\n")   # 두꺼운 폰트 (볼드 해제)
        # 감정별 스타일
        for emo, col in self.emotion_colors.items():
            header += (f"Style: {emo.capitalize()},{self.default_font},"
                       f"{self.default_font_size},{col},&HFFFFFF,&H000000,&H80000000,"
                       f"0,0,0,0,100,100,0,0,1,2,1,2,10,10,10,1\n")
        
        header += "\n[Events]\n"
        header += ("Format: Layer, Start, End, Style, Name, MarginL, MarginR, "
                   "MarginV, Effect, Text\n")
        return header
    
    def generate_ass_line(self, segment, video_info=None):
        """ASS 자막 라인 생성 수정"""
        st = self._format_time(segment['start'])
        ed = self._format_time(segment['end'])
        
        # 감정에 따른 하이라이트 색상 설정
        emotion = segment.get('emotion', 'neutral')
        highlight_color = self.emotion_colors.get(emotion, self.default_color)
        
        text = ""
        
        # 화자 정보와 본문을 하나의 자막으로 처리
        if 'speaker' in segment and segment['speaker'] != "Unknown":
            text += (
                "{\\an2}" +  # 하단 중앙 정렬
                "{\\fs" + str(int(self.default_font_size * 0.7)) + "}" +  # 화자 이름 폰트 크기
                "{\\fn" + self.default_font + "}" +  # 기본 폰트 사용
                "{\\c" + self.default_color + "}" +  # 화자 정보는 항상 흰색
                "[" + segment['speaker'] + "]" +
                "\\N\\N" +  # 두 줄 띄우기
                "{\\r}"  # 스타일 초기화
            )
            
            # 본문 스타일
            text += (
                "{\\an2}" +  # 하단 중앙 정렬
                "{\\fn" + self.default_font + "}" +  # 기본 폰트 사용
                "{\\c" + self.default_color + "}"  # 기본 텍스트는 항상 흰색
            )
        else:
            # 화자가 없는 경우
            text += (
                "{\\an2}" +  # 하단 중앙 정렬
                "{\\fn" + self.default_font + "}" +  # 기본 폰트 사용
                "{\\c" + self.default_color + "}"  # 기본 텍스트는 항상 흰색
            )

        # voice_type 기반 스타일 처리 (whisper: 이탤릭 + 반투명, shout: 두꺼운 폰트)
        voice_type = segment.get('voice_type', 'normal')
        
        # voice_type별 지속적인 스타일 태그 생성
        voice_style_on = ""
        voice_style_off = ""
        
        if voice_type == 'whisper':
            whisper_font = self.voice_fonts.get('whisper', self.default_font)
            voice_style_on = f"{{\\fn{whisper_font}\\i1\\1a&H60&}}"     # 폰트 + 이탤릭 + 반투명 적용
            voice_style_off = f"{{\\fn{self.default_font}\\i0\\1a&H00&}}" # 기본 폰트로 복원 + 이탤릭/반투명 해제
        elif voice_type == 'shout':
            shout_font = self.voice_fonts.get('shout', self.default_font)
            voice_style_on = f"{{\\fn{shout_font}}}"                     # 두꺼운 폰트 적용
            voice_style_off = f"{{\\fn{self.default_font}}}"             # 기본 폰트로 복원

        # voice_type 스타일 적용 (전체 세그먼트에)
        text += voice_style_on
        
        # 단어별 처리
        words = segment.get('words', [])
        if words:
            prev_end = words[0]['start']
            for word in words:
                if not all(key in word for key in ['start', 'end', 'word']):
                    text += word.get('word', '') + " "
                    continue

                # 단어 간격 처리
                if word['start'] > prev_end:
                    text += "{\\r}" + " " * int((word['start'] - prev_end) * 2)

                # 단어별 스타일
                word_style = []
                
                # 볼륨/피치/발화 속도 스타일 적용
                volume_level = word.get('volume_level', 'normal')
                font_size = self.volume_sizes[volume_level]
                word_style.append(f"\\fs{font_size}")
                
                pitch_level = word.get('pitch_level', 'normal')
                outline = self.pitch_outlines[pitch_level]
                word_style.append(f"\\bord{outline}")
                
                speech_rate = word.get('speech_rate', 'normal')
                spacing = self.speech_rate_spacing[speech_rate]
                word_style.append(f"\\fsp{spacing}")

                # 가라오케 효과 적용
                duration = int((word['end'] - word['start']) * 100)
                text += (
                    "{" +
                    "".join(word_style) +
                    f"\\k{duration}" +
                    f"\\1c{highlight_color}" +  # 하이라이트 색상 적용
                    "}" +
                    word['word'] +
                    "{" +
                    f"\\1c{self.default_color}" +  # 색상만 기본으로 되돌림 (볼드/이탤릭 유지)
                    "}" +
                    " "
                )
                
                prev_end = word['end']
        else:
            text += segment.get('text', '')

        # voice_type 스타일 해제
        text += voice_style_off

        # 최종 자막 라인 생성
        return f"Dialogue: 0,{st},{ed},Default,,0,0,0,,{text.rstrip()}\n"

    def generate_full_subtitle(self, segments, output_path, video_info=None):
        """전체 ASS 자막 파일 생성"""
        # 헤더 작성
        header = self.generate_ass_header(video_info)
        
        # 자막 라인 작성
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(header)
            for seg in segments:
                f.write(self.generate_ass_line(seg))
        
        print(f"ASS 파일이 저장되었습니다: {output_path}")
        return output_path
